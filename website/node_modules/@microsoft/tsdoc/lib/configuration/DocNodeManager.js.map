{"version":3,"file":"DocNodeManager.js","sourceRoot":"","sources":["../../src/configuration/DocNodeManager.ts"],"names":[],"mappings":";;AACA,uDAAsD;AAiBtD;;;;;;;GAOG;AACH;IAAA;QAMmB,8BAAyB,GACtC,IAAI,GAAG,EAAwC,CAAC;QACnC,qCAAgC,GAC7C,IAAI,GAAG,EAAoD,CAAC;IAsFlE,CAAC;IApFC;;;OAGG;IACI,yCAAgB,GAAvB,UAAwB,WAAmB,EAAE,WAA8C;QACzF,IAAM,gBAAgB,GAAuB,2BAAY,CAAC,2BAA2B,CAAC,WAAW,CAAC,CAAC;QACnG,IAAI,gBAAgB,EAAE;YACpB,MAAM,IAAI,KAAK,CAAC,4BAA4B,GAAG,gBAAgB,CAAC,CAAC;SAClE;QAED,KAAyB,UAAW,EAAX,2BAAW,EAAX,yBAAW,EAAX,IAAW,EAAE;YAAjC,IAAM,UAAU,oBAAA;YACnB,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;gBAChE,MAAM,IAAI,KAAK,CAAC,sBAAoB,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,WAAW,CAAC,gCAA6B;sBACnG,oGAAoG,CAAC,CAAC;aAC3G;YAED,IAAI,kBAAkB,GAClB,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YAE/D,IAAI,kBAAkB,KAAK,SAAS,EAAE;gBACpC,MAAM,IAAI,KAAK,CAAC,wBAAqB,UAAU,CAAC,WAAW,8BAA0B;uBACjF,SAAO,kBAAkB,CAAC,WAAa,CAAA,CAAC,CAAC;aAC9C;YAED,kBAAkB,GAAG,IAAI,CAAC,gCAAgC,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACvF,IAAI,kBAAkB,KAAK,SAAS,EAAE;gBACpC,MAAM,IAAI,KAAK,CAAC,wDAAsD,kBAAkB,CAAC,WAAa;uBAClG,SAAO,kBAAkB,CAAC,WAAa,CAAA,CAAC,CAAC;aAC9C;YAED,IAAM,aAAa,GAAiC;gBAClD,WAAW,EAAE,UAAU,CAAC,WAAW;gBACnC,WAAW,EAAE,UAAU,CAAC,WAAW;gBACnC,WAAW,aAAA;gBACX,iBAAiB,EAAE,IAAI,GAAG,EAAU;aACrC,CAAC;YAEF,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;YAC1E,IAAI,CAAC,gCAAgC,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;SAClF;IACH,CAAC;IAED;;OAEG;IACI,iDAAwB,GAA/B,UAAgC,WAAmB;QACjD,IAAI,CAAC,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;YACpD,MAAM,IAAI,KAAK,CAAC,wBAAqB,WAAW,uDAAmD,CAAC,CAAC;SACtG;IACH,CAAC;IAED;;;;;;;OAOG;IACI,kDAAyB,GAAhC,UAAiC,UAAkB,EAAE,UAAiC;QACpF,IAAM,gBAAgB,GAAiC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAEvF,KAAwB,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU,EAAE;YAA/B,IAAM,SAAS,mBAAA;YAClB,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;YAC/B,gBAAgB,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;SACnD;IACH,CAAC;IAED;;;OAGG;IACI,uCAAc,GAArB,UAAsB,UAAkB,EAAE,SAAiB;QACzD,IAAM,gBAAgB,GAAiC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QACvF,OAAO,gBAAgB,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAC3D,CAAC;IAEO,uCAAc,GAAtB,UAAuB,WAAmB;QACxC,IAAM,UAAU,GAA6C,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC7G,IAAI,UAAU,KAAK,SAAS,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,wBAAqB,WAAW,uDAAmD,CAAC,CAAC;SACtG;QACD,OAAO,UAAU,CAAC;IACpB,CAAC;IA7FD,gDAAgD;IAChD,EAAE;IACF,6BAA6B;IACL,8BAAe,GAAW,qBAAqB,CAAC;IA2F1E,qBAAC;CAAA,AA/FD,IA+FC;AA/FY,wCAAc","sourcesContent":["import { DocNode } from '../nodes/DocNode';\r\nimport { StringChecks } from '../parser/StringChecks';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type DocNodeConstructor = new (...args: any[]) => DocNode;\r\n\r\nexport interface IDocNodeDefinition {\r\n  docNodeKind: string;\r\n  constructor: DocNodeConstructor;\r\n}\r\n\r\ninterface IRegisteredDocNodeDefinition {\r\n  docNodeKind: string;\r\n  constructor: DocNodeConstructor;\r\n  packageName: string;\r\n  allowedChildKinds: Set<string>;\r\n}\r\n\r\n/**\r\n * Part of the {@link TSDocConfiguration} object.\r\n *\r\n * @remarks\r\n * If you define your own custom subclasses of `DocNode`, they must be registered with the `DocNodeManager`.\r\n * Use {@link DocNodeManager.registerAllowableChildren} to specify which {@link DocNodeContainer} subclasses\r\n * are allowed to contain your nodes.\r\n */\r\nexport class DocNodeManager {\r\n  // Matches an ASCII TypeScript-style identifier.\r\n  //\r\n  // Example: \"_myIdentifier99\"\r\n  private static readonly _nodeKindRegExp: RegExp = /^[_a-z][_a-z0-9]*$/i;\r\n\r\n  private readonly _docNodeDefinitionsByKind: Map<string, IRegisteredDocNodeDefinition>\r\n    = new Map<string, IRegisteredDocNodeDefinition>();\r\n  private readonly _docNodeDefinitionsByConstructor: Map<DocNodeConstructor, IRegisteredDocNodeDefinition>\r\n    = new Map<DocNodeConstructor, IRegisteredDocNodeDefinition>();\r\n\r\n  /**\r\n   * Registers a list of {@link IDocNodeDefinition} objects to be used with the associated\r\n   * {@link TSDocConfiguration} object.\r\n   */\r\n  public registerDocNodes(packageName: string, definitions: ReadonlyArray<IDocNodeDefinition>): void {\r\n    const packageNameError: string | undefined = StringChecks.explainIfInvalidPackageName(packageName);\r\n    if (packageNameError) {\r\n      throw new Error('Invalid NPM package name: ' + packageNameError);\r\n    }\r\n\r\n    for (const definition of definitions) {\r\n      if (!DocNodeManager._nodeKindRegExp.test(definition.docNodeKind)) {\r\n        throw new Error(`The DocNode kind ${JSON.stringify(definition.docNodeKind)} is not a valid identifier.`\r\n          + ` It must start with an underscore or letter, and be comprised of letters, numbers, and underscores`);\r\n      }\r\n\r\n      let existingDefinition: IRegisteredDocNodeDefinition | undefined\r\n        = this._docNodeDefinitionsByKind.get(definition.docNodeKind);\r\n\r\n      if (existingDefinition !== undefined) {\r\n        throw new Error(`The DocNode kind \"${definition.docNodeKind}\" was already registered`\r\n          + ` by ${existingDefinition.packageName}`);\r\n      }\r\n\r\n      existingDefinition = this._docNodeDefinitionsByConstructor.get(definition.constructor);\r\n      if (existingDefinition !== undefined) {\r\n        throw new Error(`This DocNode constructor was already registered by ${existingDefinition.packageName}`\r\n          + ` as ${existingDefinition.docNodeKind}`);\r\n      }\r\n\r\n      const newDefinition: IRegisteredDocNodeDefinition = {\r\n        docNodeKind: definition.docNodeKind,\r\n        constructor: definition.constructor,\r\n        packageName,\r\n        allowedChildKinds: new Set<string>()\r\n      };\r\n\r\n      this._docNodeDefinitionsByKind.set(definition.docNodeKind, newDefinition);\r\n      this._docNodeDefinitionsByConstructor.set(definition.constructor, newDefinition);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reports an error if the specified DocNode kind has not been registered.\r\n   */\r\n  public throwIfNotRegisteredKind(docNodeKind: string): void {\r\n    if (!this._docNodeDefinitionsByKind.has(docNodeKind)) {\r\n      throw new Error(`The DocNode kind \"${docNodeKind}\" was not registered with this TSDocConfiguration`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For the given parent DocNode kind, registers the specified DocNode kinds as being allowable children of\r\n   * the parent.\r\n   *\r\n   * @remarks\r\n   * To prevent mistakes, `DocNodeContainer` will report an error if you try to add node that was not registered\r\n   * as an allowable child of the container.\r\n   */\r\n  public registerAllowableChildren(parentKind: string, childKinds: ReadonlyArray<string>): void {\r\n    const parentDefinition: IRegisteredDocNodeDefinition = this._getDefinition(parentKind);\r\n\r\n    for (const childKind of childKinds) {\r\n      this._getDefinition(childKind);\r\n      parentDefinition.allowedChildKinds.add(childKind);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the specified DocNode kind has been registered as an allowable child of the specified\r\n   * parent DocNode kind.\r\n   */\r\n  public isAllowedChild(parentKind: string, childKind: string): boolean {\r\n    const parentDefinition: IRegisteredDocNodeDefinition = this._getDefinition(parentKind);\r\n    return parentDefinition.allowedChildKinds.has(childKind);\r\n  }\r\n\r\n  private _getDefinition(docNodeKind: string): IRegisteredDocNodeDefinition {\r\n    const definition: IRegisteredDocNodeDefinition | undefined = this._docNodeDefinitionsByKind.get(docNodeKind);\r\n    if (definition === undefined) {\r\n      throw new Error(`The DocNode kind \"${docNodeKind}\" was not registered with this TSDocConfiguration`);\r\n    }\r\n    return definition;\r\n  }\r\n}\r\n"]}